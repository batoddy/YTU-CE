$date
	Mon Apr 14 13:20:44 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module TB_datapath $end
$var wire 32 ! valA [31:0] $end
$var wire 32 " valB [31:0] $end
$var wire 1 # Zero $end
$var wire 32 $ Result [31:0] $end
$var wire 1 % Overflow $end
$var reg 3 & ALUControl [2:0] $end
$var reg 2 ' addr1 [1:0] $end
$var reg 2 ( addr2 [1:0] $end
$var reg 2 ) addr3 [1:0] $end
$var reg 1 * clk $end
$var reg 1 + rst $end
$var reg 1 , wr $end
$scope module uut $end
$var wire 3 - ALUControl [2:0] $end
$var wire 2 . addr1 [1:0] $end
$var wire 2 / addr2 [1:0] $end
$var wire 2 0 addr3 [1:0] $end
$var wire 1 * clk $end
$var wire 1 + rst $end
$var wire 1 , wr $end
$var wire 32 1 data2 [31:0] $end
$var wire 32 2 data1 [31:0] $end
$var wire 1 # Zero $end
$var wire 32 3 Result [31:0] $end
$var wire 1 % Overflow $end
$scope module RF $end
$var wire 2 4 addr1 [1:0] $end
$var wire 2 5 addr2 [1:0] $end
$var wire 2 6 addr3 [1:0] $end
$var wire 1 * clk $end
$var wire 32 7 data1 [31:0] $end
$var wire 32 8 data2 [31:0] $end
$var wire 1 + rst $end
$var wire 1 , wr $end
$var wire 32 9 data3 [31:0] $end
$upscope $end
$scope module alu $end
$var wire 32 : A [31:0] $end
$var wire 3 ; ALUControl [2:0] $end
$var wire 32 < B [31:0] $end
$var wire 32 = or_Result [31:0] $end
$var wire 32 > and_Result [31:0] $end
$var wire 1 # Zero $end
$var wire 32 ? Sum [31:0] $end
$var wire 32 @ Result [31:0] $end
$var wire 1 % Overflow $end
$var wire 1 A LT_1 $end
$var wire 32 B LT [31:0] $end
$var wire 1 C Cout $end
$var wire 32 D Bnot [31:0] $end
$var wire 32 E B_mux [31:0] $end
$scope module adder $end
$var wire 32 F A [31:0] $end
$var wire 1 G Cin $end
$var wire 32 H Sum [31:0] $end
$var wire 1 C Cout $end
$var wire 32 I B [31:0] $end
$upscope $end
$scope module and_gate $end
$var wire 32 J A [31:0] $end
$var wire 32 K B [31:0] $end
$var wire 32 L Result [31:0] $end
$upscope $end
$scope module mux $end
$var wire 32 M in0 [31:0] $end
$var wire 32 N in1 [31:0] $end
$var wire 32 O in2 [31:0] $end
$var wire 32 P in4 [31:0] $end
$var wire 32 Q in6 [31:0] $end
$var wire 32 R in7 [31:0] $end
$var wire 3 S sel [2:0] $end
$var wire 32 T in5 [31:0] $end
$var wire 32 U in3 [31:0] $end
$var reg 32 V out [31:0] $end
$upscope $end
$scope module mux_1_2 $end
$var wire 32 W a [31:0] $end
$var wire 1 X sel $end
$var wire 32 Y y [31:0] $end
$var wire 32 Z b [31:0] $end
$upscope $end
$scope module not_gate $end
$var wire 32 [ A [31:0] $end
$var wire 32 \ Result [31:0] $end
$upscope $end
$scope module or_gate $end
$var wire 32 ] A [31:0] $end
$var wire 32 ^ B [31:0] $end
$var wire 32 _ Result [31:0] $end
$upscope $end
$scope module slt $end
$var wire 1 ` A $end
$var wire 3 a ALUControl [2:0] $end
$var wire 1 b B $end
$var wire 1 A LT $end
$var wire 1 % Overflow $end
$var wire 1 c Sum $end
$var wire 1 d gate1 $end
$var wire 1 e gate2 $end
$var wire 1 f gate3 $end
$upscope $end
$scope module zero_extender $end
$var wire 1 A in $end
$var wire 32 g out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0x g
xf
xe
xd
xc
xb
bx a
x`
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
xX
bx W
b0 V
bx U
b0x T
bx S
b0 R
b0 Q
b0 P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
xG
bx F
bx E
bx D
xC
b0x B
xA
b0 @
bx ?
bx >
bx =
bx <
bx ;
bx :
b0 9
bx 8
bx 7
bx 6
bx 5
bx 4
b0 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
0,
0+
0*
bx )
bx (
bx '
bx &
x%
b0 $
1#
bx "
bx !
$end
#5000
1*
#10000
0*
#15000
b1 B
b1 T
b1 g
1A
0%
0e
1c
1d
b10011010101111001101111011101111 ?
b10011010101111001101111011101111 H
b10011010101111001101111011101111 M
b10011010101111001101111011101111 N
1C
0#
1f
0b
b11111111111111111111111111111110 E
b11111111111111111111111111111110 I
b11111111111111111111111111111110 Y
b11111111111111111111111111111110 D
b11111111111111111111111111111110 Z
b11111111111111111111111111111110 \
1`
b0 >
b0 L
b0 O
b10011010101111001101111011110001 =
b10011010101111001101111011110001 U
b10011010101111001101111011110001 _
1X
1G
b10011010101111001101111011101111 $
b10011010101111001101111011101111 3
b10011010101111001101111011101111 9
b10011010101111001101111011101111 @
b10011010101111001101111011101111 V
1*
1,
b10 )
b10 0
b10 6
b1 "
b1 1
b1 8
b1 <
b1 K
b1 W
b1 [
b1 ^
b11 (
b11 /
b11 5
b10011010101111001101111011110000 !
b10011010101111001101111011110000 2
b10011010101111001101111011110000 7
b10011010101111001101111011110000 :
b10011010101111001101111011110000 F
b10011010101111001101111011110000 J
b10011010101111001101111011110000 ]
b1 '
b1 .
b1 4
b1 &
b1 -
b1 ;
b1 S
b1 a
#20000
0*
#25000
