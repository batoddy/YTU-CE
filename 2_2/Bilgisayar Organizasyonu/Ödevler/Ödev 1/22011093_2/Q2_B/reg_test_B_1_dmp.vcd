$date
	Mon Apr 14 15:00:36 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module TB_datapath $end
$var wire 32 ! valA [31:0] $end
$var wire 32 " valB [31:0] $end
$var wire 1 # Zero $end
$var wire 32 $ Result [31:0] $end
$var wire 1 % Overflow $end
$var reg 3 & ALUControl [2:0] $end
$var reg 2 ' addr1 [1:0] $end
$var reg 2 ( addr2 [1:0] $end
$var reg 2 ) addr3 [1:0] $end
$var reg 1 * clk $end
$var reg 1 + rst $end
$var reg 1 , wr $end
$scope module uut $end
$var wire 3 - ALUControl [2:0] $end
$var wire 2 . addr1 [1:0] $end
$var wire 2 / addr2 [1:0] $end
$var wire 2 0 addr3 [1:0] $end
$var wire 1 * clk $end
$var wire 1 + rst $end
$var wire 1 , wr $end
$var wire 32 1 data2 [31:0] $end
$var wire 32 2 data1 [31:0] $end
$var wire 1 # Zero $end
$var wire 32 3 Result [31:0] $end
$var wire 1 % Overflow $end
$scope module RF $end
$var wire 2 4 addr1 [1:0] $end
$var wire 2 5 addr2 [1:0] $end
$var wire 2 6 addr3 [1:0] $end
$var wire 1 * clk $end
$var wire 32 7 data1 [31:0] $end
$var wire 32 8 data2 [31:0] $end
$var wire 1 + rst $end
$var wire 1 , wr $end
$var wire 32 9 data3 [31:0] $end
$upscope $end
$scope module alu $end
$var wire 32 : A [31:0] $end
$var wire 3 ; ALUControl [2:0] $end
$var wire 32 < B [31:0] $end
$var wire 32 = or_Result [31:0] $end
$var wire 32 > and_Result [31:0] $end
$var wire 1 # Zero $end
$var wire 32 ? Sum [31:0] $end
$var wire 32 @ Result [31:0] $end
$var wire 1 % Overflow $end
$var wire 1 A LT_1 $end
$var wire 32 B LT [31:0] $end
$var wire 1 C Cout $end
$var wire 32 D Bnot [31:0] $end
$var wire 32 E B_mux [31:0] $end
$scope module adder $end
$var wire 32 F A [31:0] $end
$var wire 1 G Cin $end
$var wire 32 H Sum [31:0] $end
$var wire 1 C Cout $end
$var wire 32 I B [31:0] $end
$upscope $end
$scope module and_gate $end
$var wire 32 J A [31:0] $end
$var wire 32 K B [31:0] $end
$var wire 32 L Result [31:0] $end
$upscope $end
$scope module mux $end
$var wire 32 M in0 [31:0] $end
$var wire 32 N in1 [31:0] $end
$var wire 32 O in2 [31:0] $end
$var wire 32 P in4 [31:0] $end
$var wire 32 Q in6 [31:0] $end
$var wire 32 R in7 [31:0] $end
$var wire 3 S sel [2:0] $end
$var wire 32 T in5 [31:0] $end
$var wire 32 U in3 [31:0] $end
$var reg 32 V out [31:0] $end
$upscope $end
$scope module mux_1_2 $end
$var wire 32 W a [31:0] $end
$var wire 1 X sel $end
$var wire 32 Y y [31:0] $end
$var wire 32 Z b [31:0] $end
$upscope $end
$scope module not_gate $end
$var wire 32 [ A [31:0] $end
$var wire 32 \ Result [31:0] $end
$upscope $end
$scope module or_gate $end
$var wire 32 ] A [31:0] $end
$var wire 32 ^ B [31:0] $end
$var wire 32 _ Result [31:0] $end
$upscope $end
$scope module slt $end
$var wire 1 ` A $end
$var wire 3 a ALUControl [2:0] $end
$var wire 1 b B $end
$var wire 1 A LT $end
$var wire 1 % Overflow $end
$var wire 1 c Sum $end
$var wire 1 d gate1 $end
$var wire 1 e gate2 $end
$var wire 1 f gate3 $end
$upscope $end
$scope module zero_extender $end
$var wire 1 A in $end
$var wire 32 g out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0x g
xf
xe
xd
xc
xb
bx a
x`
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
xX
bx W
b0 V
bx U
b0x T
bx S
b0 R
b0 Q
b0 P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
xG
bx F
bx E
bx D
xC
b0x B
xA
b0 @
bx ?
bx >
bx =
bx <
bx ;
bx :
b0 9
bx 8
bx 7
bx 6
bx 5
bx 4
b0 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
0,
0+
0*
bx )
bx (
bx '
bx &
x%
b0 $
1#
bx "
bx !
$end
#5000
1*
#10000
0*
#15000
1*
#20000
0*
#25000
b0 B
b0 T
b0 g
0A
0%
0e
0c
1d
b10 ?
b10 H
b10 M
b10 N
0C
0#
1f
0b
b1 E
b1 I
b1 Y
b11111111111111111111111111111110 D
b11111111111111111111111111111110 Z
b11111111111111111111111111111110 \
0`
b1 >
b1 L
b1 O
b1 =
b1 U
b1 _
0X
0G
b10 $
b10 3
b10 9
b10 @
b10 V
b1 )
b1 0
b1 6
b1 "
b1 1
b1 8
b1 <
b1 K
b1 W
b1 [
b1 ^
b11 (
b11 /
b11 5
b1 !
b1 2
b1 7
b1 :
b1 F
b1 J
b1 ]
b11 '
b11 .
b11 4
1,
b0 &
b0 -
b0 ;
b0 S
b0 a
#30000
1*
#35000
1#
0d
1C
b0 $
b0 3
b0 9
b0 @
b0 V
b11111111111111111111111111111101 E
b11111111111111111111111111111101 I
b11111111111111111111111111111101 Y
b11111111111111111111111111111101 D
b11111111111111111111111111111101 Z
b11111111111111111111111111111101 \
b0 ?
b0 H
b0 M
b0 N
b10 >
b10 L
b10 O
b10 =
b10 U
b10 _
1X
1G
b10 "
b10 1
b10 8
b10 <
b10 K
b10 W
b10 [
b10 ^
b1 (
b1 /
b1 5
b10 !
b10 2
b10 7
b10 :
b10 F
b10 J
b10 ]
b1 '
b1 .
b1 4
b1 &
b1 -
b1 ;
b1 S
b1 a
1,
1*
#40000
0*
#45000
